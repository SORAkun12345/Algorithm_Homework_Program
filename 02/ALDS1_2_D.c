/*
Shell Sort
次のプログラムは、挿入ソート(ALDS1_1_A)を応用して 
 個の整数を含む数列 
 を昇順に整列するプログラムです。

1  insertionSort(A, n, g)
2      for i = g to n-1
3          v = A[i]
4          j = i - g
5          while j >= 0 && A[j] > v
6              A[j+g] = A[j]
7              j = j - g
8              cnt++
9          A[j+g] = v
10
11 shellSort(A, n)
12     cnt = 0
13     m = ?
14     G[] = {?, ?,..., ?}
15     for i = 0 to m-1
16         insertionSort(A, n, G[i])
shellSort(A, n) は、一定の間隔 
 だけ離れた要素のみを対象とした挿入ソートである insertionSort(A, n, g) を、最初は大きい値から 
 を狭めながら繰り返します。これをシェルソートと言います。

上の疑似コードの ? を埋めてこのプログラムを完成させてください。
 と数列 
 が与えられるので、疑似コード中の 
、
 個の整数 
、入力 
を昇順にした列を出力するプログラムを作成してください。ただし、出力は以下の条件を満 たす必要があります。

cnt の値は 
 を超えてはならない
入力
1 行目に整数 
 が与えられます。続く 
 行目に 
 個の整数 
 が与えられます。

出力
1 行目に整数 
、2 行目に 
 個の整数 
 を空白区切りで出力してください。
3 行目に、
 を用いた場合のプログラムが終了した直後の cnt　の値を出力してください。
続く 
 行に整列した 
 を出力してください。

この問題では、１つの入力に対して複数の解答があります。条件を満たす出力は全て正解となります。

制約
入力例 1
5
5
1
4
3
2
出力例 1
2
4 1
3
1
2
3
4
5
入力例 2
3
3
2
1
出力例 2
1
1
3
1
2
3
*/

#include <stdio.h>

// 交換回数を記録する変数をグローバルで宣言
long long cnt;
int G[100]; // 間隔Gを保存する配列（十分なサイズ）
int m;      // Gの要素数

// 間隔gを指定した挿入ソート
void insertionSort(int A[], int n, int g) {
    for (int i = g; i < n; i++) {
        int v = A[i];
        int j = i - g;
        while (j >= 0 && A[j] > v) {
            A[j + g] = A[j];
            j = j - g;
            cnt++; // 移動回数をカウント
        }
        A[j + g] = v;
    }
}

// シェルソート本体
void shellSort(int A[], int n) {
    cnt = 0;
    
    // 数列Gを生成する: h = 3*h + 1 (1, 4, 13, 40, 121...)
    // nより小さい最大の値まで生成する
    m = 0;
    int h = 1;
    /* まずは数列を逆順に一時的な配列などに入れるか、
       あるいはループで生成して配列に詰め込んでから、
       実際に使うときに逆順にするのが一般的です。
       ここではシンプルに「逆順で格納していく」実装にします。
    */
   
    // まずhをnを超えない範囲で大きくする
    // (制約によってはここを調整しますが、一般的に h = 3*h + 1)
    // ただし、簡単な実装として「配列に詰め込んでから逆順に出力」します。
    
    // 一時的な配列
    int tempG[100];
    int k = 0;
    h = 1;
    while(h <= n){
        tempG[k++] = h;
        h = 3 * h + 1;
    }
    
    // 生成した数列を逆順にしてGに格納 (大きい間隔からソートするため)
    // もしnが小さくてループに入らなかった場合(n=0など)のケアが必要ですが
    // n>=1なら必ず1は入ります
    if (k == 0) tempG[k++] = 1; // nが小さい時の安全策

    m = k;
    for(int i = 0; i < m; i++){
        G[i] = tempG[m - 1 - i]; // 逆順にコピー
    }

    // 生成した間隔Gを使って挿入ソートを繰り返す
    for (int i = 0; i < m; i++) {
        insertionSort(A, n, G[i]);
    }
}

int main() {
    int n;
    // データ数の読み込み
    if (scanf("%d", &n) != 1) return 0;

    int A[n];
    for (int i = 0; i < n; i++) {
        scanf("%d", &A[i]);
    }

    // シェルソート実行
    shellSort(A, n);

    // 出力形式に従って表示
    // 1行目: m (Gの個数)
    printf("%d\n", m);

    // 2行目: Gの要素をスペース区切りで出力
    for (int i = 0; i < m; i++) {
        if (i > 0) printf(" ");
        printf("%d", G[i]);
    }
    printf("\n");

    // 3行目: cnt (移動回数)
    printf("%lld\n", cnt);

    // 続くn行: ソート済みの配列
    for (int i = 0; i < n; i++) {
        printf("%d\n", A[i]);
    }

    return 0;
}