/* ============================================================
 * アルゴリズム: 挿入ソート (Insertion Sort)
 * ============================================================
 * 概要:
 *   - 配列の先頭から順に、各要素を左側の整列済み部分に
 *     正しい位置を探して挿入していくアルゴリズム
 *   - 左側は常にソート済み状態を保つため、段階的に
 *     整列範囲が拡大していく
 *   - 安定ソート（同じ値の相対順序が変わらない）
 *
 * 時間計算量:
 *   - 平均: O(N^2)     - N/2 回のシフトが平均
 *   - 最悪: O(N^2)     - 逆順の場合、最大 N-1 回のシフト
 *   - 最良: O(N)       - 既にソート済みの場合
 *
 * 空間計算量: O(1)（in-place ソート、追加メモリ不要）
 *
 * アルゴリズムの動作:
 *   1. i を 1 から N-1 まで順に処理
 *      （A[0] は初期状態でソート済み）
 *   2. A[i] を挿入対象 v として保存
 *   3. A[0..i-1] の中で A[j] > v となる要素を右に1つずつシフト
 *   4. シフト後の空いた位置に v を挿入
 *   5. 各ステップ後に配列全体を出力
 *
 * 入出力:
 *   - 入力: N（要素数）、続いて N 個の整数
 *   - 出力: 初期配列、および各挿入後の配列状態
 *          （初期 + N-1 回 = 計 N 行）
 *
 * 具体例:
 *   入力: 6 / 5 2 4 6 1 3
 *   ステップ:
 *     i=1: [5 | 2...] → 2 を挿入 → [2 5 4 6 1 3]
 *     i=2: [2 5 | 4...] → 4 を挿入 → [2 4 5 6 1 3]
 *     i=3: [2 4 5 | 6...] → 6 を挿入 → [2 4 5 6 1 3]
 *     i=4: [2 4 5 6 | 1...] → 1 を挿入 → [1 2 4 5 6 3]
 *     i=5: [1 2 4 5 6 | 3] → 3 を挿入 → [1 2 3 4 5 6]
 * ============================================================ */
#include <stdio.h>

void insertionSort(int A[], int N);
void printArray(int A[], int N);

int main(){
    int N;
    scanf("%d", &N);

    int A[N];

    for(int i = 0; i < N; i++){
        scanf("%d", &A[i]);
    }

    insertionSort(A, N);
}

void insertionSort(int A[], int N){
    printArray(A, N);
    for(int i = 1; i < N; i++){
        int v = A[i];
        int j = i - 1;
        while(j >= 0 && A[j] > v){
            A[j+1] = A[j];
            j--;
        }
        A[j+1] = v;
        printArray(A, N);
    }
}

void printArray(int A[], int N){
    for(int i = 0; i < N; i++){
        if (i > 0) printf(" "); 
        printf("%d", A[i]);
    }
    printf("\n");
}