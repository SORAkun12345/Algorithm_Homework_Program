/*
Partition
partition ( A, p, r )は、配列 A[ p..r ] を A[ p..q − 1] の各要素が A[q] 以下で、A[ q +1.. r ] の各要素が A[ q ] より大きい A[ p..q − 1] と A[q + 1..r ] に分割し、インデックス q を戻り値として返します。

数列 
 を読み込み、次の疑似コードに基づいた partition を行うプログラムを作成してください。

1 partition(A, p, r)
2   x = A[r]
3   i = p-1
4   for j = p to r-1
4     if A[j] <= x
5       i = i+1
6       A[i] と A[j] を交換
7   A[i+1] と A[r] を交換
8   return i+1
ここで、
 は配列 
 の最後の要素を指す添え字で、
 を基準として配列を分割することに注意してください。

入力
入力の最初の行に、数列 
 の長さを表す整数 
 が与えられます。２行目に、
 個の整数 
 (
) が空白区切りで与えられます。

出力
分割された数列を1行に出力してください。数列の連続する要素は１つの空白で区切って出力してください。また、partition の基準となる要素を [   ]で示してください。

制約
入力例 1
12
13 19 9 5 12 8 7 4 21 2 6 11
出力例 1
9 5 8 7 4 2 6 [11] 21 13 19 12
*/

/*
Partition（分割）の解説

【Partitionとは】
クイックソートの基本となるアルゴリズム
基準値（ピボット）よりも小さい要素と大きい要素に分割

【基本的な考え方】
- 最後の要素を基準値xとして選択
- 2つのポインタ（iとj）を使用して分割
  - i: 基準値以下の要素がある領域の末端
  - j: スキャン中の位置

【Partitionのアルゴリズム】

■最初の状態
配列: [13, 19, 9, 5, 12, 8, 7, 4, 21, 2, 6, 11]
基準値x = 11（最後の要素）
i = -1（初期値はp-1）

■ステップごとの処理
j=0: A[0]=13 > 11 → スキップ
j=1: A[1]=19 > 11 → スキップ
j=2: A[2]=9 <= 11 → i=0, swap(A[0], A[2]): [9, 19, 13, 5, 12, 8, 7, 4, 21, 2, 6, 11]
j=3: A[3]=5 <= 11 → i=1, swap(A[1], A[3]): [9, 5, 13, 19, 12, 8, 7, 4, 21, 2, 6, 11]
j=4: A[4]=12 > 11 → スキップ
j=5: A[5]=8 <= 11 → i=2, swap(A[2], A[5]): [9, 5, 8, 19, 12, 13, 7, 4, 21, 2, 6, 11]
j=6: A[6]=7 <= 11 → i=3, swap(A[3], A[6]): [9, 5, 8, 7, 12, 13, 19, 4, 21, 2, 6, 11]
j=7: A[7]=4 <= 11 → i=4, swap(A[4], A[7]): [9, 5, 8, 7, 4, 13, 19, 12, 21, 2, 6, 11]
j=8: A[8]=21 > 11 → スキップ
j=9: A[9]=2 <= 11 → i=5, swap(A[5], A[9]): [9, 5, 8, 7, 4, 2, 19, 12, 21, 13, 6, 11]
j=10: A[10]=6 <= 11 → i=6, swap(A[6], A[10]): [9, 5, 8, 7, 4, 2, 6, 12, 21, 13, 19, 11]

■最後にピボット配置
swap(A[i+1], A[r]): swap(A[7], A[11])
結果: [9, 5, 8, 7, 4, 2, 6, 11, 21, 13, 19, 12]
       基準値11は位置7に確定

【重要なポイント】
1. iはA[j] <= xの要素が格納される領域を管理
2. i+1がピボットの最終位置
3. 左側：全てxより小さい
4. 右側：全てxより大きい

【計算量】
時間計算量: O(n) - 配列を1回走査
空間計算量: O(1) - インプレース処理
*/

#include <stdio.h>

// partition関数
// 配列Aをp～rの範囲でピボット（A[r]）を基準に分割
// 戻り値：分割後のピボット位置
int partition(int A[], int p, int r) {
    int x = A[r];  // ピボット：最後の要素
    int i = p - 1; // 基準値以下の要素がある領域の末端
    
    // j を p から r-1 まで走査
    for (int j = p; j < r; j++) {
        // A[j] が基準値以下なら、i+1の位置に移動
        if (A[j] <= x) {
            i = i + 1;
            // A[i] と A[j] を交換
            int temp = A[i];
            A[i] = A[j];
            A[j] = temp;
        }
    }
    
    // ピボットを最終位置に配置
    int temp = A[i + 1];
    A[i + 1] = A[r];
    A[r] = temp;
    
    return i + 1;  // 分割位置を返す
}

int main(void) {
    int n;
    scanf("%d", &n);
    
    int A[n];
    for (int i = 0; i < n; i++) {
        scanf("%d", &A[i]);
    }
    
    // partition を実行（インデックス0～n-1で分割）
    int q = partition(A, 0, n - 1);
    
    // 分割された結果を出力
    for (int i = 0; i < n; i++) {
        if (i > 0) printf(" ");
        
        if (i == q) {
            // ピボット位置は[]で囲む
            printf("[%d]", A[i]);
        } else {
            printf("%d", A[i]);
        }
    }
    printf("\n");
    
    return 0;
}