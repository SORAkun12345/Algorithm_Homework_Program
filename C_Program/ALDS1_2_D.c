/*
Shell Sort
次のプログラムは、挿入ソート(ALDS1_1_A)を応用して 
 個の整数を含む数列 
 を昇順に整列するプログラムです。

1  insertionSort(A, n, g)
2      for i = g to n-1
3          v = A[i]
4          j = i - g
5          while j >= 0 && A[j] > v
6              A[j+g] = A[j]
7              j = j - g
8              cnt++
9          A[j+g] = v
10
11 shellSort(A, n)
12     cnt = 0
13     m = ?
14     G[] = {?, ?,..., ?}
15     for i = 0 to m-1
16         insertionSort(A, n, G[i])
shellSort(A, n) は、一定の間隔 
 だけ離れた要素のみを対象とした挿入ソートである insertionSort(A, n, g) を、最初は大きい値から 
 を狭めながら繰り返します。これをシェルソートと言います。

上の疑似コードの ? を埋めてこのプログラムを完成させてください。
 と数列 
 が与えられるので、疑似コード中の 
、
 個の整数 
、入力 
を昇順にした列を出力するプログラムを作成してください。ただし、出力は以下の条件を満 たす必要があります。

cnt の値は 
 を超えてはならない
入力
1 行目に整数 
 が与えられます。続く 
 行目に 
 個の整数 
 が与えられます。

出力
1 行目に整数 
、2 行目に 
 個の整数 
 を空白区切りで出力してください。
3 行目に、
 を用いた場合のプログラムが終了した直後の cnt　の値を出力してください。
続く 
 行に整列した 
 を出力してください。

この問題では、１つの入力に対して複数の解答があります。条件を満たす出力は全て正解となります。

制約
入力例 1
5
5
1
4
3
2
出力例 1
2
4 1
3
1
2
3
4
5
入力例 2
3
3
2
1
出力例 2
1
1
3
1
2
3
*/

/*
シェルソートの解説

【アルゴリズムの仕組み】
1. 大きな間隔gで要素を分割し、各グループを挿入ソート
2. 間隔を徐々に狭めて(g=4 → g=1)繰り返す
3. 最後にg=1で通常の挿入ソートを実行

【間隔列の生成】
h = 3*h + 1 で生成: 1, 4, 13, 40, 121, ...
→ n以下の値を逆順に使用

【なぜ効率的か】
- 大きな間隔で粗く整列 → データが「ほぼ整列」状態に
- 小さな間隔での挿入ソートが高速化（移動距離が短い）
- 計算量: O(n^1.5) 程度

【例】配列 [5, 1, 4, 3, 2], n=5
間隔列G = [4, 1]
1) g=4: [2, 1, 4, 3, 5] (間隔4の要素を比較)
2) g=1: [1, 2, 3, 4, 5] (通常の挿入ソート)
*/

#include <stdio.h>

long long cnt;    // 要素の移動回数をカウント
int A[1000000];   // ソート対象の配列
int n;            // 配列のサイズ
int G[50];        // 間隔列（最大50個）
int m;            // 間隔列の個数

// 間隔gで挿入ソート（シェルソートのサブルーチン）
// g=1なら通常の挿入ソート、g>1なら飛び飛びの挿入ソート
void insertionSort(int A[], int n, int g) {
    for (int i = g; i < n; i++) {
        int v = A[i];          // 挿入する値
        int j = i - g;         // g個前の位置から比較開始
        
        // vより大きい要素を右にg個ずつずらす
        while (j >= 0 && A[j] > v) {
            A[j + g] = A[j];   // g個右にずらす
            j = j - g;         // g個前へ
            cnt++;             // 移動回数をカウント
        }
        A[j + g] = v;          // 適切な位置にvを挿入
    }
}

// シェルソート本体
void shellSort(int A[], int n) {
    cnt = 0;
    m = 0;
    
    // 間隔列Gを生成: h = 3*h + 1 (1, 4, 13, 40, ...)
    // n以下の値を配列Gに格納
    for (int h = 1; h <= n; h = 3 * h + 1) {
        G[m++] = h;
    }
    
    // 大きい間隔から小さい間隔へ降順で挿入ソート
    // 例: G = [1, 4, 13] なら 13 → 4 → 1 の順
    for (int i = m - 1; i >= 0; i--) {
        insertionSort(A, n, G[i]);
    }
}

int main(void) {
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &A[i]);
    }
    
    shellSort(A, n);
    
    // 出力1: 間隔列の個数m
    printf("%d\n", m);
    
    // 出力2: 間隔列G（降順）を空白区切りで1行に
    for (int i = m - 1; i >= 0; i--) {
        if (i < m - 1) printf(" ");
        printf("%d", G[i]);
    }
    printf("\n");
    
    // 出力3: 要素の移動回数cnt
    printf("%lld\n", cnt);
    
    // 出力4: ソート済み配列（各要素を1行ずつ）
    for (int i = 0; i < n; i++) {
        printf("%d\n", A[i]);
    }
    
    return 0;
}
