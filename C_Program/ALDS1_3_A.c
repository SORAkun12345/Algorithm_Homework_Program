/*
スタック
逆ポーランド記法は、演算子をオペランドの後に記述する数式やプログラムを記述する記法です。例えば、一般的な中間記法で記述された数式 (1+2)*(5+4) は、逆ポーランド記法では 1 2 + 5 4 + * と記述されます。逆ポーランド記法では、中間記法で必要とした括弧が不要である、というメリットがあります。

逆ポーランド記法で与えられた数式の計算結果を出力してください。

入力
１つの数式が１行に与えられます。連続するシンボル（オペランドあるいは演算子）は１つの空白で区切られて与えられます。

出力
計算結果を１行に出力してください。

制約
2 ≤ 式に含まれるオペランドの数 ≤ 100
1 ≤ 式に含まれる演算子の数 ≤ 99
演算子は +、-、* のみを含み、１つのオペランドは106 以下の正の整数
-1 × 109 ≤ 計算途中の値 ≤ 109
入力例 1
1 2 +
出力例 1
3
入力例 2
1 2 + 3 4 - *
出力例 2
-3
*/

/*
逆ポーランド記法の解説

【逆ポーランド記法とは】
演算子をオペランドの後に記述する記法
例: (1+2)*(5+4) → 1 2 + 5 4 + *

【スタックを使った計算方法】
1. 数値が来たらスタックに積む(push)
2. 演算子が来たら:
   - スタックから2つ取り出す(pop)
   - 演算を実行
   - 結果をスタックに積む(push)
3. 最後にスタックに残った値が答え

【例】1 2 + 3 4 - *
処理:        スタック
1     →     [1]
2     →     [1, 2]
+     →     [3]        (1+2=3)
3     →     [3, 3]
4     →     [3, 3, 4]
-     →     [3, -1]    (3-4=-1)
*     →     [-3]       (3*(-1)=-3)

答え: -3
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX 100

// スタックの実装
int stack[MAX];
int top = 0;

// スタックに値を積む
void push(int x) {
    stack[top++] = x;
}

// スタックから値を取り出す
int pop() {
    return stack[--top];
}

int main(void) {
    char s[100];
    
    // 入力を空白区切りで読み込んで処理
    while (scanf("%s", s) != EOF) {
        // 数値かどうかを判定（演算子でないもの）
        if (s[0] == '+' || s[0] == '-' || s[0] == '*') {
            // 演算子の場合
            int b = pop();  // 右オペランド
            int a = pop();  // 左オペランド
            
            // 演算を実行してスタックに積む
            if (s[0] == '+') {
                push(a + b);
            } else if (s[0] == '-') {
                push(a - b);
            } else if (s[0] == '*') {
                push(a * b);
            }
        } else {
            // 数値の場合、スタックに積む
            push(atoi(s));
        }
    }
    
    // スタックに残った値が答え
    printf("%d\n", pop());
    
    return 0;
}
