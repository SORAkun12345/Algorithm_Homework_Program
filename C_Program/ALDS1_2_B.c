/*
選択ソート
選択ソートは、各計算ステップで１つの最小値を「選択」していく、直観的なアルゴリズムです。

1 selectionSort(A, N) // N個の要素を含む0-オリジンの配列A
2   for i が 0 から N-1 まで
3     minj = i
4     for j が i から N-1 まで
5       if A[j] < A[minj]
6         minj = j
7     A[i] と A[minj] を交換
数列Aを読み込み、選択ソートのアルゴリズムで昇順に並び替え出力するプログラムを作成してください。上の疑似コードに従いアルゴリズムを実装してください。

疑似コード 7 行目で、i と minj が異なり実際に交換が行われた回数も出力してください。

入力
入力の最初の行に、数列の長さを表す整数 N が与えられます。２行目に、N 個の整数が空白区切りで与えられます。

出力
出力は 2 行からなります。１行目に整列された数列を 1 行に出力してください。数列の連続する要素は１つの空白で区切って出力してください。2 行目に交換回数を出力してください。

制約
1 ≤ N ≤ 100
0 ≤ A の要素 ≤ 100
入力例 1
6
5 6 4 2 1 3
出力例 1
1 2 3 4 5 6
4

入力例 2
6
5 2 4 6 1 3
出力例 2
1 2 3 4 5 6
3
*/

#include<stdio.h>

// 選択ソートで配列を昇順に並び変え、交換回数を返す関数
int selectionSort(int x[],int n){
    int count = 0;
    int minj,temp;

    // 各位置 i に対して最小値を探す
    for(int i = 0;i < n;i++){
        // 位置 i を最小値の位置として初期化
        minj = i;
        // i から n-1 までの範囲で最小値を探す
        for(int j = i; j < n; j++){
            // x[j] が現在の最小値 x[minj] より小さければ
            if(x[j] < x[minj]){
                // minj を j に更新（最小値の位置を更新）
                minj = j;
            }
        }
        // 最小値が現在位置 i と異なる場合、交換を実行
        if(i != minj){
            // 一時変数を使って x[i] と x[minj] を交換
            temp = x[minj];
            x[minj] = x[i];
            x[i] = temp;
            // 実際に交換が行われた回数をカウント
            count++;
        }
    }
    return count;
}

int main(){
    int n;
    // 配列の長さを読み込む
    scanf("%d",&n);

    // n個の要素を格納する配列
    int x[n];
    // 配列要素を読み込む
    for(int i = 0; i < n; i++){
        scanf("%d",&x[i]);
    }

    // 選択ソートを実行し、交換回数を取得
    int count = selectionSort(x,n);

    // ソート済み配列を出力（要素間にスペースを挿入）
    for(int i = 0; i < n; i++){
        // i > 0 の場合、要素の前にスペースを挿入
        if(i) printf(" ");
        printf("%d",x[i]);
    }
    // 改行の後、交換回数を出力
    printf("\n%d\n",count);

    return 0;
}