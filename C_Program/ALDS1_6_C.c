/*
クイックソート
 枚のカードの列を整列します。１枚のカードは絵柄(S, H, C, またはD)と数字のペアで構成されています。これらを以下の疑似コードに基づくクイックソートで数字に関して昇順に整列するプログラムを作成してください。partition は ALDS1_6_B の疑似コードに基づくものとします。

1 quicksort(A, p, r)
2   if p < r
3     q = partition(A, p, r)
4     quickSort(A, p, q-1)
5     quickSort(A, q+1, r)
ここで、
 はカードが格納された配列であり、partition における比較演算はカードに書かれた「数」を基準に行われるものとします。

また、与えられた入力に対して安定な出力を行っているかを報告してください。ここでは、同じ数字を持つカードが複数ある場合、それらが入力で与えられた順序であらわれる出力を「安定な出力」とします。

入力
1行目にカードの枚数 
 が与えられます。

2行目以降で 
 枚のカードが与えられます。各カードは絵柄を表す１つの文字と数（整数）のペアで１行に与えられます。絵柄と数は１つの空白で区切られています。

出力
1行目に、この出力が安定か否か（StableまたはNot stable）を出力してください。

2行目以降で、入力と同様の形式で整列されたカードを順番に出力してください（
 を出力する必要はありません）。

制約
カードに書かれている数
入力に絵柄と数の組が同じカードは２枚以上含まれない
入力例 1
6
D 3
H 2
D 1
S 3
D 2
C 1
出力例 1
Not stable
D 1
C 1
D 2
H 2
D 3
S 3
入力例 2
2
S 1
H 1
出力例 2
Stable
S 1
H 1
*/

/*
クイックソートの解説

【クイックソートとは】
分割統治型のソートアルゴリズム
平均時間計算量: O(n log n)
最悪時間計算量: O(n²) - ピボット選択が悪い場合

【安定性について】
クイックソートは「不安定なソート」
理由: partition で要素が大きく移動するため、
      同じ値の要素の相対順序が保証されない

【安定性の判定ロジック】
ソート後に隣接する要素をチェック：
- 同じ値のカードペアで、元のid が逆順 → "Not stable"
- 元の入力順がずっと保たれている → "Stable"

例: (H,2)がid=1, (D,2)がid=3 の場合
  入力順: id1 (H,2) → id3 (D,2)
  ソート後: id3 (D,2) → id1 (H,2)  ← 逆転 → Not stable

【クイックソートの流れ】
1. 最後の要素をピボットとして選択
2. partition で分割
3. 左右を再帰的にソート

【具体例: D3, H2, D1, S3, D2, C1】
各カードに元のid を付与：
D3(id=0), H2(id=1), D1(id=2), S3(id=3), D2(id=4), C1(id=5)

ソート結果:
D1(id=2), C1(id=5), D2(id=4), H2(id=1), D3(id=0), S3(id=3)

ソート後、同じ値の隣接ペアをチェック：
- D1とC1: 値が異なる
- C1とD2: 値が異なる
- D2とH2: 値が異なる
- H2とD3: 値が異なる
- D3とS3: 値が異なる

同じ値のペア：なし

ただし全体をチェック：
- H2(id=1) と D2(id=4): 値が同じで id順序が入力順と異なる可能性
  → 実装では隣接ペアのみチェック

【実装のポイント】
1. DATA 構造体に c（絵柄）, a（値）, id（元の入力順）を保持
2. partition でカードの値（a フィールド）を基準に比較
3. quick_sort で再帰的に分割・ソート
4. ソート後、隣接する要素で同じ値かつ id が逆順をチェック
*/

#include <stdio.h>

// カード構造体
typedef struct {
    char c;     // 絵柄: S, H, C, D
    int a;      // 数字: 1-13
    int id;     // 元の入力順序
} DATA;

// partition関数（ALDS1_6_B に基づく）
// ピボット: a[hi] の値を基準に分割
int partition(DATA *a, int lo, int hi) {
    int i, j;
    int key;
    DATA t;
    
    key = a[hi].a;  // ピボット値
    i = lo - 1;
    
    // lo から hi-1 まで走査
    for (j = lo; j < hi; j++) {
        // a[j] の値がピボット以下なら、i+1 の位置に移動
        if (a[j].a <= key) {
            i++;
            t = a[i];
            a[i] = a[j];
            a[j] = t;
        }
    }
    
    // ピボットを最終位置に配置
    t = a[++i];
    a[i] = a[hi];
    a[hi] = t;
    
    return i;  // 分割位置を返す
}

// クイックソート関数
void quick_sort(DATA *a, int lo, int hi) {
    int mi;
    
    if (lo < hi) {
        mi = partition(a, lo, hi);
        quick_sort(a, lo, mi - 1);  // 左側を再帰的にソート
        quick_sort(a, mi + 1, hi);  // 右側を再帰的にソート
    }
}

DATA a[100002];

int main(void) {
    int N, i, f;
    
    scanf("%d", &N);
    
    // 入力を読み込み
    for (i = 0; i < N; i++) {
        scanf(" %c %d", &a[i].c, &a[i].a);
        a[i].id = i;  // 元の入力順を記録
    }
    
    // クイックソート実行
    quick_sort(a, 0, N - 1);
    
    // 安定性判定
    // 同じ値のカード が元のid順 と異なったら不安定
    f = 0;
    for (i = 1; i < N; i++) {
        // 隣接する要素で同じ値かつ元のid が逆順 → 不安定
        if (a[i - 1].a == a[i].a && a[i - 1].id > a[i].id) {
            f = 1;
            break;
        }
    }
    
    // 出力
    if (f) {
        printf("Not stable\n");
    } else {
        printf("Stable\n");
    }
    
    for (i = 0; i < N; i++) {
        printf("%c %d\n", a[i].c, a[i].a);
    }
    
    return 0;
}