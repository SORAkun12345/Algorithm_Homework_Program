/*
キュー
名前 namei と必要な処理時間 timei を持つ n 個のプロセスが順番に一列に並んでいます。ラウンドロビンスケジューリングと呼ばれる処理方法では、CPU がプロセスを順番に処理します。各プロセスは最大 q ms（これをクオンタムと呼びます）だけ処理が実行されます。q ms だけ処理を行っても、まだそのプロセスが完了しなければ、そのプロセスは列の最後尾に移動し、CPU は次のプロセスに割り当てられます。

例えば、クオンタムを 100 msとし、次のようなプロセスキューを考えます。

A(150) - B(80) - C(200) - D(200)
まずプロセス A が 100 ms だけ処理され残りの必要時間 50 ms を保持しキューの末尾に移動します。

B(80) - C(200) - D(200) - A(50)
次にプロセス B が 80 ms だけ処理され、時刻 180 ms で終了し、キューから削除されます。

C(200) - D(200) - A(50)
次にプロセス C が 100 ms だけ処理され、残りの必要時間 100 ms を保持し列の末尾に移動します。

D(200) - A(50) - C(100)
このように、全てのプロセスが終了するまで処理を繰り返します。

ラウンドロビンスケジューリングをシミュレートするプログラムを作成してください。

入力
入力の形式は以下の通りです。

n q
name1 time1
name2 time2
...
namen timen
最初の行に、プロセス数を表す整数 n とクオンタムを表す整数 q が１つの空白区切りで与えられます。

続く n 行で、各プロセスの情報が順番に与えられます。文字列 namei と整数 timei は１つの空白で区切られています。

出力
プロセスが完了した順に、各プロセスの名前と終了時刻を空白で区切って１行に出力してください。

制約
1 ≤ n ≤ 100,000
1 ≤ q ≤ 1,000
1 ≤ timei ≤ 50,000
1 ≤ 文字列 namei の長さ ≤ 10
1 ≤ timei の合計 ≤ 1,000,000
入力例 1
5 100
p1 150
p2 80
p3 200
p4 350
p5 20
出力例 1
p2 180
p5 400
p1 450
p3 550
p4 800
*/

/*
ラウンドロビンスケジューリングの解説

【キューとは】
先入れ先出し(FIFO: First In First Out)のデータ構造
最初に入れたものが最初に出てくる（行列と同じ）

【ラウンドロビンの処理手順】
1. キューの先頭からプロセスを取り出す
2. クオンタムq ms分だけ処理する
3. まだ時間が残っていれば、キューの末尾に戻す
4. 完了していれば、終了時刻を出力
5. キューが空になるまで繰り返す

【例】q=100の場合
初期: A(150) - B(80) - C(200) - D(200)
時刻0:   A→100ms処理 → B(80) - C(200) - D(200) - A(50)
時刻100: B→80ms処理→完了(180ms) → C(200) - D(200) - A(50)
時刻180: C→100ms処理 → D(200) - A(50) - C(100)
時刻280: D→100ms処理 → A(50) - C(100) - D(100)
時刻380: A→50ms処理→完了(430ms) → C(100) - D(100)
時刻430: C→100ms処理→完了(530ms) → D(100)
時刻530: D→100ms処理→完了(630ms) → 終了
*/

#include <stdio.h>
#include <string.h>

#define MAX 100000

// プロセス構造体
typedef struct {
    char name[11];
    int time;
} Process;

// キューの実装（配列による循環キュー）
Process queue[MAX];
int head = 0;  // キューの先頭
int tail = 0;  // キューの末尾
int size = 0;  // キューのサイズ

// キューにプロセスを追加（enqueue）
void enqueue(Process p) {
    queue[tail] = p;
    tail = (tail + 1) % MAX;
    size++;
}

// キューからプロセスを取り出す（dequeue）
Process dequeue() {
    Process p = queue[head];
    head = (head + 1) % MAX;
    size--;
    return p;
}

int main(void) {
    int n, q;
    scanf("%d %d", &n, &q);
    
    // 初期プロセスをキューに登録
    for (int i = 0; i < n; i++) {
        Process p;
        scanf("%s %d", p.name, &p.time);
        enqueue(p);
    }
    
    int current_time = 0;
    
    // キューが空になるまで処理
    while (size > 0) {
        Process p = dequeue();
        
        if (p.time <= q) {
            // クオンタム以内に終了する場合
            current_time += p.time;
            printf("%s %d\n", p.name, current_time);
        } else {
            // クオンタムで処理しきれない場合
            current_time += q;
            p.time -= q;
            enqueue(p);  // キューの末尾に戻す
        }
    }
    
    return 0;
}
