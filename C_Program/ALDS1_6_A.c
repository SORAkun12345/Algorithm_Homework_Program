/*
計数ソート
計数ソートは各要素が 0 以上 
 以下である要素数 
 の数列に対して線形時間(
)で動く安定なソーティングアルゴリズムです。

入力数列 
 の各要素 
 について、
 以下の要素の数をカウンタ配列 
 に記録し、その値を基に出力配列 
 における 
 の位置を求めます。同じ数の要素が複数ある場合を考慮して、要素 
 を出力（
 に入れる）した後にカウンタ 
 は修正する必要があります。詳しくは以下の疑似コードを参考にしてください。

1 CountingSort(A, B, k)
2     for i = 0 to k
3         C[i] = 0
4
5     // C[i] に i の出現数を記録する
6     for j = 1 to n
7         C[A[j]]++
8
9     // C[i] に i 以下の数の出現数を記録する
10    for i = 1 to k
11        C[i] = C[i] + C[i-1]
12
13    for j = n downto 1
14        B[C[A[j]]] = A[j]
15        C[A[j]]--
数列 
 を読み込み、計数ソートのアルゴリズムで昇順に並び替え出力するプログラムを作成してください。上記疑似コードに従ってアルゴリズムを実装してください。

入力
入力の最初の行に、数列 
 の長さを表す整数 
 が与えられます。２行目に、
 個の整数が空白区切りで与えられます。

出力
整列された数列を1行に出力してください。数列の連続する要素は１つの空白で区切って出力してください。

制約
入力例 1
7
2 5 1 3 2 3 0
出力例 1
0 1 2 2 3 3 5
*/

/*
計数ソートの解説

【計数ソートとは】
整数のみに対して使える特殊なソートアルゴリズム
時間計算量: O(n + k) - 要素数nと最大値kに依存
安定ソート: 同じ値の要素の相対順序が保たれる

【なぜ高速か】
比較ソート（クイックソート、マージソートなど）の限界はO(n log n)
しかし計数ソートは「比較」を行わず、各値の出現位置を直接計算

【アルゴリズムの流れ】

1. C配列で出現回数をカウント
   例: A = [2, 5, 1, 3, 2, 3, 0]
   C = [1, 1, 2, 2, 0, 1] (C[i]はiの出現回数)

2. C配列を累積和に変換
   各値より小さい値がいくつあるか記録
   C = [1, 2, 4, 6, 6, 7] (C[i]はi以下の値の個数)

3. 後ろから前へ走査して出力位置を確定
   - A[n] = A[7] = 0 → C[0]=1 → B[1]=0, C[0]--
   - A[6] = A[6] = 3 → C[3]=6 → B[6]=3, C[3]--
   - ... (後ろから処理することで安定性を実現)

【具体例】A = [2, 5, 1, 3, 2, 3, 0]

■ステップ1: 出現回数をカウント
C配列: [1, 1, 2, 2, 0, 1]
  0は1回、1は1回、2は2回、3は2回、4は0回、5は1回

■ステップ2: 累積和に変換
C配列: [1, 2, 4, 6, 6, 7]
  0以下: 1個、1以下: 2個、2以下: 4個、3以下: 6個、...

■ステップ3: 後ろから処理（安定性のため）
j=7: A[7]=0, B[C[0]]=B[1]=0, C[0]--
j=6: A[6]=3, B[C[3]]=B[6]=3, C[3]--
j=5: A[5]=3, B[C[3]]=B[5]=3, C[3]--
j=4: A[4]=2, B[C[2]]=B[4]=2, C[2]--
j=3: A[3]=2, B[C[2]]=B[3]=2, C[2]--
j=2: A[2]=1, B[C[1]]=B[2]=1, C[1]--
j=1: A[1]=5, B[C[5]]=B[7]=5, C[5]--

結果: B = [_, 0, 1, 2, 2, 3, 3, 5]

【なぜ後ろから処理するのか】
同じ値が複数ある場合、後ろから処理することで
元の配列での相対順序を保つ（安定性）

【制約】
- 値が0以上kの整数のみ対応
- 値が非常に大きいと、C配列が巨大になり不効率
*/

#include <stdio.h>
#include <string.h>

#define MAX_N 100001
#define MAX_K 100001

int main(void) {
    int n;
    scanf("%d", &n);
    
    int A[n + 1];
    int k = 0;  // 最大値を記録
    
    for (int i = 1; i <= n; i++) {
        scanf("%d", &A[i]);
        if (A[i] > k) {
            k = A[i];
        }
    }
    
    // C配列: 出現回数と累積和を記録
    int C[k + 1];
    memset(C, 0, sizeof(C));
    
    // ステップ1: 各値の出現回数をカウント
    for (int j = 1; j <= n; j++) {
        C[A[j]]++;
    }
    
    // ステップ2: 累積和に変換（i以下の値の個数）
    for (int i = 1; i <= k; i++) {
        C[i] = C[i] + C[i - 1];
    }
    
    // B配列: 出力結果を格納
    int B[n + 1];
    
    // ステップ3: 後ろから処理（安定性を保つ）
    for (int j = n; j >= 1; j--) {
        B[C[A[j]]] = A[j];
        C[A[j]]--;
    }
    
    // 出力
    for (int i = 1; i <= n; i++) {
        if (i > 1) printf(" ");
        printf("%d", B[i]);
    }
    printf("\n");
    
    return 0;
}
