C_Programディレクトリ - アルゴリズム詳細一覧
================================================================

Chapter 1: 入門
----------------
ALDS1_1_A: 挿入ソート (Insertion Sort)
  - N個の整数を含む配列を昇順に整列
  - 各ステップでの配列の状態を出力
  - 時間計算量: O(N²)

ALDS1_1_B: 最大公約数 (Greatest Common Divisor)
  - ユークリッドの互除法を用いて2つの自然数の最大公約数を求める
  - gcd(x, y) = gcd(y, x mod y) の再帰的な性質を利用
  - 時間計算量: O(log min(x,y))

ALDS1_1_C: 素数判定 (Prime Numbers)
  - n個の整数を読み込み、素数の個数を出力
  - 素数: 1とその数自身のみを約数に持つ自然数
  - √nまでの数で割り切れるかチェック

ALDS1_1_D: 最大利益 (Maximum Profit)
  - FX取引での最大利益を求める
  - 時刻tにおける価格列から「買い→売り」で得られる最大差分を計算
  - 動的に最小値を更新しながら最大差分を求める

Chapter 2: ソート
----------------
ALDS1_2_A: バブルソート (Bubble Sort)
  - 隣接要素を比較して交換を繰り返す
  - 交換回数をカウント
  - 時間計算量: O(N²)、安定ソート

ALDS1_2_B: 選択ソート (Selection Sort)
  - 各ステップで最小値を選択して先頭に移動
  - 交換回数をカウント
  - 時間計算量: O(N²)、不安定ソート

ALDS1_2_C: 安定なソート (Stable Sort)
  - トランプカードを整列し、ソートの安定性を検証
  - バブルソートと選択ソートを両方実装して比較
  - 安定性: 同じキーを持つ要素の相対順序が保たれるか

ALDS1_2_D: シェルソート (Shell Sort)
  - 挿入ソートを改良した高速なソートアルゴリズム
  - 一定間隔(gap)ごとに要素を取り出して挿入ソートを適用
  - 使用したgap列と比較回数を出力

Chapter 3: データ構造
----------------
ALDS1_3_A: スタック (Stack)
  - 逆ポーランド記法の数式を計算
  - LIFO(後入れ先出し)構造
  - push/pop操作で四則演算を実行

ALDS1_3_B: キュー (Queue)
  - ラウンドロビンスケジューリングをシミュレート
  - FIFO(先入れ先出し)構造
  - クオンタム時間ごとにプロセスを処理

ALDS1_3_C: 双方向連結リスト (Doubly Linked List)
  - insert, delete, deleteFirst, deleteLast操作を実装
  - 前後のノードへのポインタを持つ
  - 要素の追加・削除が効率的

ALDS1_3_D: 断面図の水たまり面積 (Areas on Cross-Section Diagram)
  - 地形の断面図から水たまりの面積を計算
  - スタックを使って左右の壁を追跡
  - 各水たまりの面積と総面積を出力

Chapter 4: 探索
----------------
ALDS1_4_A: 線形探索 (Linear Search)
  - 配列Sの要素がすべて配列Tに含まれるか判定
  - 順番に要素を比較
  - 時間計算量: O(N×Q)

ALDS1_4_B: 二分探索 (Binary Search)
  - ソート済み配列に対して効率的に探索
  - 探索範囲を半分ずつ絞り込む
  - 時間計算量: O(Q log N)

ALDS1_4_C: 辞書 (Dictionary)
  - ハッシュテーブルを用いた辞書の実装
  - insert: 文字列を追加
  - find: 文字列が存在するか判定
  - 平均時間計算量: O(1)

ALDS1_4_D: 割り当て問題 (Allocation)
  - N個の荷物をK台のトラックに積む
  - 二分探索を使って最小の最大積載量を求める
  - 判定問題に帰着させて解く

Chapter 5: 再帰・分割統治法
----------------
ALDS1_5_A: 総当たり (Exhaustive Search)
  - 部分和問題: 配列の要素の組み合わせで指定の値が作れるか
  - ビット全探索で2^N通りの組み合わせをチェック
  - 時間計算量: O(2^N × Q)

ALDS1_5_B: マージソート (Merge Sort)
  - 分割統治法による効率的なソート
  - 配列を分割→再帰的にソート→マージ
  - 時間計算量: O(N log N)、安定ソート

ALDS1_5_C: コッホ曲線 (Koch Curve)
  - フラクタル図形を再帰的に生成
  - 線分を3等分し、中央に正三角形の突起を作る
  - 深さNの再帰呼び出しで頂点座標を出力

ALDS1_5_D: 反転数 (The Number of Inversions)
  - 数列中のi<jかつA[i]>A[j]となるペアの個数
  - マージソートの過程でカウント
  - バブルソートの交換回数と等しい

Chapter 6: ソート応用
----------------
ALDS1_6_A: 計数ソート (Counting Sort)
  - 各値の出現回数をカウントして整列
  - 0以上k以下の整数に対して線形時間でソート
  - 時間計算量: O(N+k)、安定ソート

ALDS1_6_B: パーティション (Partition)
  - クイックソートの基本操作
  - 配列を基準値より小さい部分と大きい部分に分割
  - 基準値の最終位置を返す

ALDS1_6_C: クイックソート (Quick Sort)
  - パーティションを再帰的に適用
  - トランプカードをソートして安定性を検証
  - 平均時間計算量: O(N log N)、不安定ソート

ALDS1_6_D: 最小コストソート (Minimum Cost Sort)
  - 要素の交換にコスト(重みの合計)がかかる場合の最小コスト
  - 各サイクルごとに最適な交換方法を選択
  - サイクル内の最小値または全体の最小値を使う

Chapter 7: 木構造
----------------
ALDS1_7_A: 根付き木 (Rooted Trees)
  - 各節点の親、深さ、種類(根/内部節点/葉)、子のリストを出力
  - 木構造の基本的な性質を理解
  - DFSまたはBFSで深さを計算

ALDS1_7_B: 二分木 (Binary Trees)
  - 各節点の親、兄弟、子の数、深さ、高さ、種類を出力
  - 左の子と右の子を持つ
  - 再帰的に高さを計算

ALDS1_7_C: 木の巡回 (Tree Walk)
  - 先行順巡回(Preorder): 根→左→右
  - 中間順巡回(Inorder): 左→根→右
  - 後行順巡回(Postorder): 左→右→根
  - 3種類の巡回結果を出力

ALDS1_7_D: 木の再構築 (Reconstruction of a Tree)
  - Preorder(先行順)とInorder(中間順)から木を復元
  - Postorder(後行順)の巡回結果を出力
  - 分割統治法で再帰的に構築

Chapter 8: 二分探索木
----------------
ALDS1_8_A: 二分探索木 I (Binary Search Tree I)
  - insert命令でキーを挿入
  - print命令でinorder巡回とpreorder巡回の結果を出力
  - 二分探索木条件: 左部分木 ≤ 根 < 右部分木

ALDS1_8_B: 二分探索木 II (Binary Search Tree II)
  - find命令を追加: キーが存在するか判定
  - 探索操作を実装
  - 平均時間計算量: O(log N)

ALDS1_8_C: 二分探索木 III (Binary Search Tree III)
  - delete命令を追加: キーを持つ節点を削除
  - 3つのケース: 葉/片側の子/両側の子
  - 後続節点(successor)を使って削除

ALDS1_8_D: Treap (Treap)
  - 二分探索木とヒープを組み合わせた平衡木
  - keyとpriorityの2つの値を持つ
  - 回転操作で平衡を保つ

Chapter 9: ヒープ
----------------
ALDS1_9_A: 完全二分木 (Complete Binary Tree)
  - 配列表現された完全二分木
  - 親・左の子・右の子のインデックス関係
  - parent(i)=i/2, left(i)=2i, right(i)=2i+1

ALDS1_9_B: 最大ヒープ構築 (Maximum Heap)
  - max-heap条件: 親 ≥ 子
  - buildMaxHeapで配列をヒープ化
  - maxHeapify操作で部分木をヒープ化

ALDS1_9_C: 優先度付きキュー (Priority Queue)
  - insert: 要素を挿入
  - extract: 最大キーを持つ要素を取り出し
  - max-heapを使って実装

ALDS1_9_D: ヒープソート (Heap Sort)
  - max-heapを使った効率的なソート
  - buildMaxHeap→繰り返しextractMax
  - 時間計算量: O(N log N)、不安定ソート

Chapter 10: 動的計画法
----------------
ALDS1_10_A: フィボナッチ数列 (Fibonacci Number)
  - fib(n) = fib(n-1) + fib(n-2)
  - メモ化で計算量を削減
  - 時間計算量: O(N)

ALDS1_10_B: 連鎖行列積 (Matrix Chain Multiplication)
  - N個の行列の積の計算順序を最適化
  - スカラー乗算回数を最小化
  - 動的計画法で最適な分割点を求める

ALDS1_10_C: 最長共通部分列 (Longest Common Subsequence)
  - 2つの列の最長共通部分列の長さを求める
  - dp[i][j]: X[0..i]とY[0..j]のLCS長
  - 時間計算量: O(M×N)

ALDS1_10_D: 最適二分探索木 (Optimal Binary Search Tree)
  - 探索コストの期待値が最小となる二分探索木
  - 各キーの探索確率を考慮
  - 動的計画法で最適な構造を求める

Chapter 11: グラフ I
----------------
ALDS1_11_A: グラフ表現 (Graph)
  - 隣接リスト形式から隣接行列形式へ変換
  - N×Nの行列で辺の有無を表現
  - 空間計算量: O(V²)

ALDS1_11_B: 深さ優先探索 (Depth First Search)
  - できるだけ深く探索する戦略
  - 発見時刻(d)と完了時刻(f)を記録
  - スタック(再帰)を使って実装

ALDS1_11_C: 幅優先探索 (Breadth First Search)
  - できるだけ浅く、層ごとに探索
  - 始点から各頂点への最短距離を求める
  - キューを使って実装

ALDS1_11_D: 連結成分分解 (Connected Components)
  - SNSの友達関係で到達可能性を判定
  - Union-Find木を使って素集合を管理
  - 経路圧縮で効率化

Chapter 12: グラフ II (最短経路・最小全域木)
----------------
ALDS1_12_A: 最小全域木 (Minimum Spanning Tree)
  - プリム法で全頂点を含む最小コストの木を構築
  - 訪問済み頂点から最小コストの辺を選択
  - 時間計算量: O(V²)

ALDS1_12_B: 単一始点最短経路 I (Single Source Shortest Path I)
  - ダイクストラ法で始点から各頂点への最短経路を求める
  - 距離が最小の未訪問頂点を順番に確定
  - 時間計算量: O(V²)

ALDS1_12_C: 単一始点最短経路 II (Single Source Shortest Path II)
  - ダイクストラ法の高速化版
  - min-heapを使って最小距離の頂点を効率的に取得
  - 時間計算量: O((V+E) log V)

Chapter 13: 発見的探索
----------------
ALDS1_13_A: 8クイーン問題 (8 Queens Problem)
  - 8×8チェス盤に8個のクイーンを配置
  - どのクイーンも他を襲撃できない配置を求める
  - バックトラックで全探索、衝突検出配列で高速化

ALDS1_13_B: 8パズル (8 Puzzle)
  - 3×3の盤面で空白を動かしてゴール状態を目指す
  - 双方向BFSで最短手数を求める
  - ハッシュテーブルで状態管理

ALDS1_13_C: 15パズル (15 Puzzle)
  - 4×4の盤面で空白を動かしてゴール状態を目指す
  - A*探索でヒューリスティック関数を使用
  - マンハッタン距離を評価関数に利用

補足: 入出力・実装メモ（ファイル別）
----------------------------------------
ALDS1_1_A: 入力=配列長と数列 / 出力=各ステップの配列 / 主要構造=配列
ALDS1_1_B: 入力=2整数 / 出力=gcd / 主要構造=再帰 or ループ
ALDS1_1_C: 入力=nとn個の整数 / 出力=素数の個数 / 主要構造=ループ
ALDS1_1_D: 入力=価格列 / 出力=最大利益 / 主要構造=最小値の更新

ALDS1_2_A: 入力=数列 / 出力=整列結果と交換回数 / 主要構造=配列
ALDS1_2_B: 入力=数列 / 出力=整列結果と交換回数 / 主要構造=配列
ALDS1_2_C: 入力=カード列 / 出力=各ソート結果と安定性 / 主要構造=構造体配列
ALDS1_2_D: 入力=数列 / 出力=gap列と比較回数と結果 / 主要構造=配列

ALDS1_3_A: 入力=逆ポーランド式 / 出力=計算結果 / 主要構造=スタック
ALDS1_3_B: 入力=プロセス列と量子 / 出力=完了時刻 / 主要構造=キュー
ALDS1_3_C: 入力=操作列 / 出力=リスト内容 / 主要構造=双方向連結リスト
ALDS1_3_D: 入力=断面図の文字列 / 出力=総面積と各水たまり / 主要構造=スタック

ALDS1_4_A: 入力=配列SとT / 出力=一致数 / 主要構造=線形探索
ALDS1_4_B: 入力=ソート済み配列SとT / 出力=一致数 / 主要構造=二分探索
ALDS1_4_C: 入力=insert/find命令 / 出力=yes/no / 主要構造=ハッシュ表
ALDS1_4_D: 入力=荷物重量と台数 / 出力=最小積載量 / 主要構造=二分探索判定

ALDS1_5_A: 入力=数列と問い合わせ / 出力=yes/no / 主要構造=再帰全探索
ALDS1_5_B: 入力=数列 / 出力=整列結果と比較回数 / 主要構造=分割統治
ALDS1_5_C: 入力=深さN / 出力=頂点座標 / 主要構造=再帰
ALDS1_5_D: 入力=数列 / 出力=反転数 / 主要構造=マージソート

ALDS1_6_A: 入力=数列 / 出力=整列結果 / 主要構造=頻度配列
ALDS1_6_B: 入力=数列 / 出力=partition後の列 / 主要構造=配列
ALDS1_6_C: 入力=カード列 / 出力=整列結果と安定性 / 主要構造=クイックソート
ALDS1_6_D: 入力=重み列 / 出力=最小コスト / 主要構造=サイクル分解

ALDS1_7_A: 入力=親子関係 / 出力=節点情報 / 主要構造=隣接リスト
ALDS1_7_B: 入力=二分木情報 / 出力=各節点情報 / 主要構造=配列で子管理
ALDS1_7_C: 入力=二分木情報 / 出力=3巡回結果 / 主要構造=再帰
ALDS1_7_D: 入力=preorder/inorder / 出力=postorder / 主要構造=再帰分割

ALDS1_8_A: 入力=命令列 / 出力=巡回結果 / 主要構造=BST
ALDS1_8_B: 入力=命令列 / 出力=yes/noと巡回 / 主要構造=BST
ALDS1_8_C: 入力=命令列 / 出力=巡回結果 / 主要構造=BST+削除
ALDS1_8_D: 入力=命令列 / 出力=巡回結果 / 主要構造=Treap

ALDS1_9_A: 入力=配列 / 出力=親子情報 / 主要構造=配列木
ALDS1_9_B: 入力=配列 / 出力=最大ヒープ / 主要構造=heapify
ALDS1_9_C: 入力=命令列 / 出力=extract結果 / 主要構造=最大ヒープ
ALDS1_9_D: 入力=配列 / 出力=整列結果 / 主要構造=ヒープソート

ALDS1_10_A: 入力=n / 出力=fib(n) / 主要構造=DP配列
ALDS1_10_B: 入力=行列次元 / 出力=最小コスト / 主要構造=DP表
ALDS1_10_C: 入力=複数の文字列ペア / 出力=LCS長 / 主要構造=DP表
ALDS1_10_D: 入力=キーと確率 / 出力=最小期待コスト / 主要構造=DP表

ALDS1_11_A: 入力=隣接リスト / 出力=隣接行列 / 主要構造=行列
ALDS1_11_B: 入力=隣接リスト / 出力=発見/完了時刻 / 主要構造=DFS
ALDS1_11_C: 入力=隣接リスト / 出力=最短距離 / 主要構造=BFS
ALDS1_11_D: 入力=辺と問合せ / 出力=yes/no / 主要構造=Union-Find

ALDS1_12_A: 入力=隣接行列 / 出力=最小全域木コスト / 主要構造=Prim
ALDS1_12_B: 入力=隣接リスト / 出力=各頂点の距離 / 主要構造=Dijkstra
ALDS1_12_C: 入力=隣接リスト / 出力=各頂点の距離 / 主要構造=Dijkstra+heap

ALDS1_13_A: 入力=既配置クイーン / 出力=盤面 / 主要構造=バックトラック
ALDS1_13_B: 入力=8パズル盤面 / 出力=最短手数 / 主要構造=双方向BFS
ALDS1_13_C: 入力=15パズル盤面 / 出力=最短手数 / 主要構造=A*探索

================================================================
合計: 49ファイル

基本的なアルゴリズムとデータ構造を網羅的に実装した教育用コレクション
