/*
割り当て
重さがそれぞれ 
 の 
 個の荷物が、ベルトコンベアから順番に流れてきます。これらの荷物を 
 台のトラックに積みます。各トラックには連続する 0 個以上の荷物を積むことができますが、それらの重さの和がトラックの最大積載量 
 を超えてはなりません。最大積載量 
 はすべてのトラックで共通です。

、
、
 が与えられるので、すべての荷物を積むために必要な最大積載量 
 の最小値を求めるプログラムを作成してください。

入力
最初の行に荷物の数 
 とトラックの数 
 が空白区切りで与えられます。続く 
 行に 
 個の整数 
 がそれぞれ１行に与えられます。

出力
 の最小値を１行に出力してください。

制約
入力例 1
5 3
8
1
7
3
9
出力例 1
10
１台目のトラックに２つの荷物 
,２台目のトラックに２つの荷物 
、３台目のトラックに１つの荷物 
 を積んで、最大積載量の最小値が 10 となります。


入力例 2
4 2
1
2
2
6
出力例 2
6
１台目のトラックに３つの荷物 
,２台目のトラックに１つの荷物 
 を積んで、最大積載量の最小値が 6 となります。
*/

/*
割り当て問題（二分探索の応用）の解説

【問題の本質】
最大積載量Pの最小値を求める最適化問題
→ 「答えに対する二分探索」で解決

【アルゴリズムの仕組み】
1. 答えの範囲を決定
   - 最小値: max(荷物の重さ) ← 最大の荷物は必ず積める必要がある
   - 最大値: sum(全荷物の重さ) ← 全部を1台に積む場合

2. 二分探索で答えを探す
   left = max(w[i]), right = sum(w[i])
   while (left < right) {
       mid = (left + right) / 2
       if (check(mid)) → midで積める
           right = mid  // より小さい値を探す
       else
           left = mid + 1  // より大きい値が必要
   }

3. check関数: 容量Pで全荷物をk台以内に積めるか判定
   - 荷物を順番に現在のトラックに積む
   - 積めなくなったら次のトラックへ
   - 使用台数がk以下ならtrue

【具体例】入力例1: n=5, k=3, w=[8,1,7,3,9]
初期: left=9（最大荷物）, right=28（合計）

1回目: mid=18
  check(18): [8,1,7] [3,9] → 2台で積める → right=18
  
2回目: left=9, right=18, mid=13
  check(13): [8,1] [7,3] [9] → 3台で積める → right=13
  
3回目: left=9, right=13, mid=11
  check(11): [8,1] [7,3] [9] → 3台で積める → right=11
  
4回目: left=9, right=11, mid=10
  check(10): [8,1] [7,3] [9] → 3台で積める → right=10
  
5回目: left=9, right=10, mid=9
  check(9): [8] [1,7] [3] [9] → 4台必要 → left=10
  
終了: left=10 → 答え10

【なぜこれが正しいか】
- check(P)がtrueなら、P以上の値でもtrue（単調性）
- 二分探索で最小のtrueとなるPを見つける
- 計算量: O(n log(sum)) ← check関数がO(n)、二分探索がO(log(sum))
*/

#include <stdio.h>

int n, k;
int w[100000];

// 最大積載量がPのとき、k台以内で全荷物を積めるか判定
int check(int P) {
    int i = 0;
    int trucks = 1;  // 使用するトラック台数
    int current_load = 0;  // 現在のトラックの積載量
    
    while (i < n) {
        // 荷物がトラックに積める場合
        if (current_load + w[i] <= P) {
            current_load += w[i];
            i++;
        } else {
            // 積めない場合、次のトラックへ
            trucks++;
            current_load = 0;
            
            // トラック台数が超過した場合は不可能
            if (trucks > k) {
                return 0;
            }
        }
    }
    
    return 1;  // k台以内で積めた
}

int main(void) {
    scanf("%d %d", &n, &k);
    
    int left = 0;   // 最小値: 最大の荷物の重さ
    int right = 0;  // 最大値: 全荷物の合計
    
    for (int i = 0; i < n; i++) {
        scanf("%d", &w[i]);
        if (w[i] > left) {
            left = w[i];
        }
        right += w[i];
    }
    
    // 二分探索で最小の最大積載量を求める
    while (left < right) {
        int mid = (left + right) / 2;
        
        if (check(mid)) {
            // midで積める → より小さい値を探す
            right = mid;
        } else {
            // midでは積めない → より大きい値が必要
            left = mid + 1;
        }
    }
    
    printf("%d\n", left);
    
    return 0;
}
