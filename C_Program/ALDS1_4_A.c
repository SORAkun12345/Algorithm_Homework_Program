/*
線形探索
 個の整数を含む数列 
 と、
 個の異なる整数を含む数列 
 を読み込み、
 に含まれる整数の中で 
 に含まれるものの個数 
 を出力するプログラムを作成してください。

入力
１行目に 
、２行目に 
 を表す 
 個の整数、３行目に 
、４行目に 
 を表す 
 個の整数が与えられます。

出力
 を１行に出力してください。

制約
の要素
の要素
 の要素は互いに異なる
入力例 1
5
1 2 3 4 5
3
3 4 1
出力例 1
3
入力例 2
3
3 1 2
1
5
出力例 2
0
入力例 3
5
1 1 2 2 3
2
1 2
出力例 3
2
*/

/*
線形探索の解説

【線形探索とは】
配列の先頭から順番に目的の要素を探す最も基本的な探索アルゴリズム
時間計算量: O(n)

【番兵（sentinel）の活用】
通常の線形探索では、ループ内で「配列の範囲チェック」と「要素の一致チェック」の
2つの条件判定が必要:
  while (i < n && A[i] != key)

番兵を使うと:
1. 配列の末尾（n番目）に探索対象のkeyを配置
2. これにより必ず途中でkeyが見つかるため、範囲チェックが不要に
3. ループ内の条件判定が1つで済む: while (A[i] != key)
4. 最後に「末尾で見つかったか（=実際には存在しない）」を判定

【具体例】
配列S = [1, 2, 3, 4, 5], key = 3 を探す場合

■ 番兵なし:
  i=0: i<5 && S[0]!=3 → 真 → 継続
  i=1: i<5 && S[1]!=3 → 真 → 継続
  i=2: i<5 && S[2]!=3 → 偽 → 発見！

■ 番兵あり:
  配列を [1, 2, 3, 4, 5, 3] に拡張（末尾に3を追加）
  i=0: S[0]!=3 → 真 → 継続
  i=1: S[1]!=3 → 真 → 継続
  i=2: S[2]!=3 → 偽 → 発見！
  i!=n (2!=5) なので本当に存在する

【このアルゴリズムの利点】
- 条件判定が1回で済むため高速化
- コードがシンプルになる
*/

#include <stdio.h>

// 線形探索（番兵を使用）
// 見つかったら 1, 見つからなければ 0 を返す
int linearSearch(int n, int A[], int key) {
    int i = 0;
    A[n] = key; // 配列の末尾に番兵をセット
    
    // 範囲チェック (i < n) が不要になる
    while (A[i] != key) {
        i++;
    }
    
    // 見つかった位置が末尾（番兵）でなければ真の発見
    return i != n;
}

int main(void) {
    int n, q, key;
    int count = 0;

    // 数列 S の読み込み
    scanf("%d", &n);
    int S[n + 1]; // 番兵のために 1 つ多めに確保
    for (int i = 0; i < n; i++) {
        scanf("%d", &S[i]);
    }

    // 数列 T の読み込みと同時に探索を行う
    scanf("%d", &q);
    for (int i = 0; i < q; i++) {
        scanf("%d", &key);
        // S の中に key が存在するかチェック
        if (linearSearch(n, S, key)) {
            count++;
        }
    }

    // 合計数を出力
    printf("%d\n", count);

    return 0;
}
