/*
深さ優先探索
深さ優先探索（Depth First Search: DFS）は、可能な限り隣接する頂点を訪問する、という戦略に基づくグラフの探索アルゴリズムです。未探索の接続辺が残されている頂点の中で最後に発見した頂点 
 の接続辺を再帰的に探索します。
 の辺をすべて探索し終えると、
 を発見したときに通ってきた辺を後戻りして探索を続行します。

探索は元の始点から到達可能なすべての頂点を発見するまで続き、未発見の頂点が残っていれば、その中の番号が一番小さい１つを新たな始点として探索を続けます。

深さ優先探索では、各頂点に以下のタイムスタンプを押します：

タイムスタンプ 
: 
 を最初に発見した発見時刻を記録します。
タイムスタンプ 
: 
 の隣接リストを調べ終えた完了時刻を記録します。
以下の仕様に基づき、与えられた有向グラフ 
 に対する深さ優先探索の動作を示すプログラムを作成してください：

 は隣接リスト表現の形式で与えられます。各頂点には 
 から 
 までの番号がふられています。
各隣接リストの頂点は番号が小さい順に並べられています。
プログラムは各頂点の発見時刻と完了時刻を報告します。
深さ優先探索の過程において、訪問する頂点の候補が複数ある場合は頂点番号が小さいものから選択します。
最初に訪問する頂点の開始時刻を 1 とします。
入力
最初の行に 
 の頂点数 
 が与えられます。続く 
 行で各頂点 
 の隣接リストが以下の形式で与えられます：

 
 
 
 ... 

 は頂点の番号、
 は 
 の出次数、
 　は 
 に隣接する頂点の番号を示します。

出力
各頂点について 
、 
、 
を空白区切りで１行に出力してください。
 は頂点の番号、
 はその頂点の発見時刻、
 はその頂点の完了時刻です。頂点の番号順で出力してください。

制約
入力例 1
4
1 1 2
2 1 4
3 0
4 1 3
出力例 1
1 1 8
2 2 7
3 4 5
4 3 6

入力例 2
6
1 2 2 3
2 2 3 4
3 1 5
4 1 6
5 1 6
6 0
出力例 2
1 1 12
2 2 11
3 3 8
4 9 10
5 4 7
6 5 6

入力例2に対応するグラフ(発見時刻/終了時刻)


参考文献
Introduction to Algorithms, Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. The MIT Press.
*/

/*
深さ優先探索（DFS）の解説

【DFSとは】
グラフの全ての頂点を訪問するアルゴリズム
「できるだけ深く」進みながら探索

【タイムスタンプの意味】
d[u]: 頂点uを最初に発見した時刻
f[u]: 頂点uの全ての隣接頂点を調べ終えた時刻

【DFSの流れ】

例: 頂点1 → 2 → 4 → 3 → （戻る）
    1-1:発見, 2-2:発見, 4-3:発見, 3-4:発見, 3-5:完了, 4-6:完了, 2-7:完了, 1-8:完了

タイムスタンプの付与：
- 頂点を訪問した時に d[u] = ++timer
- 頂点の全隣接頂点を探索し終えたとき f[u] = ++timer

【具体例1】
グラフ:
1 → 2 → 4 → 3 (→はなし)

DFS実行:
timer=0

訪問(1): d[1]=1, timer=1
  訪問(2): d[2]=2, timer=2
    訪問(4): d[4]=3, timer=3
      訪問(3): d[3]=4, timer=4
        (3から出ていく辺なし)
      完了(3): f[3]=5, timer=5
    完了(4): f[4]=6, timer=6
  完了(2): f[2]=7, timer=7
完了(1): f[1]=8, timer=8

結果:
1 1 8
2 2 7
3 4 5
4 3 6

【具体例2】
グラフが複数のコンポーネントに分かれている場合：
- 1つ目のコンポーネント: 1→2→3→5→6, 4→6
- timer は続きの値から開始

訪問順序: 1(d=1) → 2(d=2) → 3(d=3) → 5(d=4) → 6(d=5)
完了順序: 6(f=6) → 5(f=7) → 3(f=8) → 2(f=11)
次のコンポーネント: 4(d=9) → 6はすでに訪問済み
完了: 4(f=10)
完了: 1(f=12)

【計算量】
時間: O(V + E) - 全頂点と全辺を訪問
空間: O(V) - 再帰スタックと配列

【実装のポイント】
1. グラフを隣接行列で表現
2. visited配列で訪問済みかどうかを判定
3. d, f配列でタイムスタンプを記録
4. 未訪問の頂点から順番に DFS を開始
*/

#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#define MAX_V 101

int timer = 0;
bool visited[MAX_V];
int d[MAX_V];  // 発見時刻
int f[MAX_V];  // 完了時刻
int Adj[MAX_V][MAX_V];

// 深さ優先探索
void dfs(int u, int n) {
    visited[u] = true;
    d[u] = ++timer;  // 発見時刻を記録
    
    // u から隣接する全ての頂点を探索
    for (int v = 1; v <= n; v++) {
        if (Adj[u][v] == 1 && !visited[v]) {
            dfs(v, n);
        }
    }
    
    f[u] = ++timer;  // 完了時刻を記録
}

int main(void) {
    int n;
    scanf("%d", &n);
    
    // 隣接行列と訪問済み配列を初期化
    memset(Adj, 0, sizeof(Adj));
    memset(visited, false, sizeof(visited));
    
    // 隣接リスト形式の入力を読み込む
    for (int i = 0; i < n; i++) {
        int u, k;
        scanf("%d %d", &u, &k);
        
        for (int j = 0; j < k; j++) {
            int v;
            scanf("%d", &v);
            Adj[u][v] = 1;
        }
    }
    
    // 各頂点から DFS を開始（未訪問の場合のみ）
    for (int i = 1; i <= n; i++) {
        if (!visited[i]) {
            dfs(i, n);
        }
    }
    
    // 結果を出力
    for (int i = 1; i <= n; i++) {
        printf("%d %d %d\n", i, d[i], f[i]);
    }
    
    return 0;
}