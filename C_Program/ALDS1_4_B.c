/*
二分探索
 個の整数を含む数列 
 と、
 個の異なる整数を含む数列 
 を読み込み、
 に含まれる整数の中で 
 に含まれるものの個数 
 を出力するプログラムを作成してください。

入力
１行目に 
、２行目に 
 を表す 
 個の整数、３行目に 
、４行目に 
 を表す 
 個の整数が与えられます。

出力
 を１行に出力してください。

制約
 の要素は昇順に整列されている
の要素
の要素
 の要素は互いに異なる
入力例 1
5
1 2 3 4 5
3
3 4 1
出力例 1
3
入力例 2
3
1 2 3
1
5
出力例 2
0
入力例 3
5
1 1 2 2 3
2
1 2
出力例 3
2
*/

/*
二分探索の解説

【二分探索とは】
整列済み配列に対して、目的の要素を高速に探すアルゴリズム
時間計算量: O(log n) ← 線形探索のO(n)より圧倒的に高速

【アルゴリズムの仕組み】
1. 探索範囲の中央の要素と目的の値を比較
2. 一致すれば発見
3. 目的の値が中央より小さければ左半分を探索
4. 目的の値が中央より大きければ右半分を探索
5. 探索範囲がなくなるまで繰り返す

【具体例】配列 [1, 2, 3, 4, 5] で key=4 を探す
初期: left=0, right=4
  1回目: mid=2, S[2]=3 < 4 → 右側を探索 → left=3
  2回目: mid=3, S[3]=4 == 4 → 発見！

【具体例】配列 [1, 2, 3, 4, 5] で key=6 を探す
初期: left=0, right=4
  1回目: mid=2, S[2]=3 < 6 → 右側を探索 → left=3
  2回目: mid=3, S[3]=4 < 6 → 右側を探索 → left=4
  3回目: mid=4, S[4]=5 < 6 → 右側を探索 → left=5
  left > right なのでループ終了 → 見つからない

【なぜ高速か】
毎回探索範囲が半分になるため、n個の要素でも約log₂(n)回で終わる
例: n=1000 → 約10回, n=1000000 → 約20回

【前提条件】
配列が昇順（または降順）に整列されている必要がある
*/

#include <stdio.h>

// 二分探索: keyが配列Sの中に存在すれば1、なければ0を返す
int binarySearch(int S[], int key, int n) {
    int left = 0;
    int right = n - 1;
    int mid;

    // 左端が右端を追い越すまで続ける
    while (left <= right) {
        // 真ん中のインデックスを計算
        mid = (left + right) / 2;

        if (S[mid] == key) {
            return 1; // 見つかった
        }
        // keyの方が大きい → 右側（大きい方）を探す
        else if (S[mid] < key) {
            left = mid + 1; // 左端をmidの右隣へ
        }
        // keyの方が小さい → 左側（小さい方）を探す
        else {
            right = mid - 1; // 右端をmidの左隣へ
        }
    }
    
    return 0; // 最後まで見つからなかった
}

int main(void) {
    int n;
    scanf("%d", &n);

    int S[n];
    for (int i = 0; i < n; i++) {
        scanf("%d", &S[i]);
    }

    int q;
    scanf("%d", &q);

    int count = 0;
    for (int i = 0; i < q; i++) {
        int key;
        scanf("%d", &key);
        // Sの中にkeyが存在するかチェック
        count += binarySearch(S, key, n);
    }

    printf("%d\n", count);
    
    return 0;
}
